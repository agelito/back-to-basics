{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Back to Basics Introduction This is an example project and tutorial for making and rendering a game without using a graphics card**. We'll be calculating each individual pixel that appears on the screen using the CPU only. Some knowledge of C is expected and the operating system used by the author is Arch Linux. The project should run on most systems though and if it doesn't, only minor modifications should be necessary to make it run. The end goal of this isn't the game itself, so the tutorial will not focus much on creating a great game, but rather the fundamental building blocks. Also it should be considered mostly academic since there's better ways of rendering games using modern graphic card API's (DirectX/Vulkan/OpenGL/etc). The tutorial is split into multiple chapters. Each chapter is of arbitrary size and I'm writing them as I go along implementing each feature myself. ** SDL2 will be used for creating a window which in turn might use the graphics card to display the pixels we've defined to screen. This choice was made because the focus of this tutorial shouldn't be interacting with the OS API's for opening and managing windows.","title":"Home"},{"location":"#welcome-to-back-to-basics","text":"","title":"Welcome to Back to Basics"},{"location":"#introduction","text":"This is an example project and tutorial for making and rendering a game without using a graphics card**. We'll be calculating each individual pixel that appears on the screen using the CPU only. Some knowledge of C is expected and the operating system used by the author is Arch Linux. The project should run on most systems though and if it doesn't, only minor modifications should be necessary to make it run. The end goal of this isn't the game itself, so the tutorial will not focus much on creating a great game, but rather the fundamental building blocks. Also it should be considered mostly academic since there's better ways of rendering games using modern graphic card API's (DirectX/Vulkan/OpenGL/etc). The tutorial is split into multiple chapters. Each chapter is of arbitrary size and I'm writing them as I go along implementing each feature myself. ** SDL2 will be used for creating a window which in turn might use the graphics card to display the pixels we've defined to screen. This choice was made because the focus of this tutorial shouldn't be interacting with the OS API's for opening and managing windows.","title":"Introduction"},{"location":"1_hello_world/","text":"Hello World This part of the guide describes setting up the development environment and making sure we can build C code. None of the tools or structure used in this part if enforced, but using a similar setup will make it easier to follow the rest of the guide. Installing required tools This is a list of tools we'll need initially. More tools might be added later on as we're implementing more features. Text Editor For editing the code I'll be using Visual Studio Code . This tool is available in most linux distrubution's package repositories. In Arch Linux (pacman) it's called code and can be installed using the following command: # Arch Linux (pacman) pacman -S code Compiler To compile the code we'll be using clang . clang is a C, C++, and Objective-C compiler which encompasses preprocessing, parsing, optimization, code generation, assembly, and linking. clang can be installed from most distributions package repositories: # Arch Linux (pacman) pacman -S clang Build System cmake and ninja will be used to build the code. We'll just install them for now and cover configuration at a later point. # Arch Linux (pacman) pacman -S cmake ninja Creating basic project directories Aiming to keep the directory structure as simple as possible for now, we'll just create a root directory for the project and one directory for source code. Later on there's also going to be one directory for the cmake build. # Create directories and hello_world source file. mkdir back-to-basics && cd back-to-basics mkdir src && touch src/hello_world.c mkdir bin # Initialize git repository so the source code changes can be tracked. git init && touch .gitignore # Open the project with VSCode code . Creating hello_world Open the src/hello_world.c file and input the following content. All this file is responsible for is printing Hello, World! to the terminal and then exit. It's purpose is just to ensure we can compile and run C code. #include <stdio.h> int main(int argc, char* argv[]) { printf(\"Hello, World!\\n\"); return 0; } Building hello_world For now src/hello_world.c will just be built with default options. Later on we'll be using cmake to configure various build options and settings and not invoke the clang compiler manually. # Compile and link the hello_world program. clang -o bin/hello_world --std=c11 src/main.c # Run hello_world ./bin/hello_world After running these commands Hello, World! should be printed to the terminal. Congratulations we've just built our first C program. Commit changes To track our code changes over time we'll commit the hello_world program using git . We don't want to include files built from the source code so we'll also put some folders to be ignored inside the .gitignore file. Open the .gitignore file and insert the following: bin/ Now commit the changes the following files will be added to our commit: .gitignore src/hello_world.c To commit use the following commands: git add . git commit -m \"feat: create hello_world sample program\"","title":"1. Hello World"},{"location":"1_hello_world/#hello-world","text":"This part of the guide describes setting up the development environment and making sure we can build C code. None of the tools or structure used in this part if enforced, but using a similar setup will make it easier to follow the rest of the guide.","title":"Hello World"},{"location":"1_hello_world/#installing-required-tools","text":"This is a list of tools we'll need initially. More tools might be added later on as we're implementing more features.","title":"Installing required tools"},{"location":"1_hello_world/#text-editor","text":"For editing the code I'll be using Visual Studio Code . This tool is available in most linux distrubution's package repositories. In Arch Linux (pacman) it's called code and can be installed using the following command: # Arch Linux (pacman) pacman -S code","title":"Text Editor"},{"location":"1_hello_world/#compiler","text":"To compile the code we'll be using clang . clang is a C, C++, and Objective-C compiler which encompasses preprocessing, parsing, optimization, code generation, assembly, and linking. clang can be installed from most distributions package repositories: # Arch Linux (pacman) pacman -S clang","title":"Compiler"},{"location":"1_hello_world/#build-system","text":"cmake and ninja will be used to build the code. We'll just install them for now and cover configuration at a later point. # Arch Linux (pacman) pacman -S cmake ninja","title":"Build System"},{"location":"1_hello_world/#creating-basic-project-directories","text":"Aiming to keep the directory structure as simple as possible for now, we'll just create a root directory for the project and one directory for source code. Later on there's also going to be one directory for the cmake build. # Create directories and hello_world source file. mkdir back-to-basics && cd back-to-basics mkdir src && touch src/hello_world.c mkdir bin # Initialize git repository so the source code changes can be tracked. git init && touch .gitignore # Open the project with VSCode code .","title":"Creating basic project directories"},{"location":"1_hello_world/#creating-hello_world","text":"Open the src/hello_world.c file and input the following content. All this file is responsible for is printing Hello, World! to the terminal and then exit. It's purpose is just to ensure we can compile and run C code. #include <stdio.h> int main(int argc, char* argv[]) { printf(\"Hello, World!\\n\"); return 0; }","title":"Creating hello_world"},{"location":"1_hello_world/#building-hello_world","text":"For now src/hello_world.c will just be built with default options. Later on we'll be using cmake to configure various build options and settings and not invoke the clang compiler manually. # Compile and link the hello_world program. clang -o bin/hello_world --std=c11 src/main.c # Run hello_world ./bin/hello_world After running these commands Hello, World! should be printed to the terminal. Congratulations we've just built our first C program.","title":"Building hello_world"},{"location":"1_hello_world/#commit-changes","text":"To track our code changes over time we'll commit the hello_world program using git . We don't want to include files built from the source code so we'll also put some folders to be ignored inside the .gitignore file. Open the .gitignore file and insert the following: bin/ Now commit the changes the following files will be added to our commit: .gitignore src/hello_world.c To commit use the following commands: git add . git commit -m \"feat: create hello_world sample program\"","title":"Commit changes"},{"location":"2_build_system/","text":"Build System To avoid having to manually invoke the clang compiler manually each time we want to build the project, as well as allowing dependencies to be specified regardless of which computer or operating system is used we'll set up cmake to generate a project and then use ninja to build. cmake use a file called CMakeLists.txt to determine which dependencies, input files, and outputs should be generated. We'll create a minimal CMakeLists.txt file to build our hello_world program using that instead. touch CMakeLists.txt Open CMakeLists.txt and type the following: cmake_minimum_required(VERSION 3.24) project(back_to_basics) # The path to clang might vary depending on system set(CMAKE_C_COMPILER /usr/bin/clang) # Use the c11 standard set(CMAKE_C_STANDARD 11) # Define the hello_world executable target add_executable(hello_world src/hello_world.c) Now use cmake to generate the Ninja project configuration and then build the project: mkdir build && cd build cmake -GNinja ../. ninja After runnig the previous commands a new hello_world executable has been generated try running it to ensure we still see the Hello, World! output being printed: ./hello_world Since we don't want to commit the build directory into git we'll add it to the ignore list. Open .gitignore file and replace all contents with the following: build/ To clean up from the manual build made earlier we can remove the old bin/ directory as well. cd .. && rm -rf bin Commit the changes using git: git add . && git commit -m \"feat: minimum cmake configuration to build hello_world\" Visual Studio Code It's recommended to install the C/C++ Extension Pack for Visual Studio Code before proceeding with setting up the building and debugging tasks. https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools-extension-pack. We can configure tasks to build and debug the application in Visual Studio Code. This will allow us to press F7 to build. Building Start by creating the .vscode directory and a tasks.json file. mkdir .vscode && touch .vscode/tasks.json We'll populate the .vscode/tasks.json file with two tasks, one task for generating the ninja build configuration using cmake and one task to invoke ninja to build the project. { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"CMake Generate Debug\", \"type\": \"shell\", \"command\": \"cmake\", \"args\": [ \"-GNinja\", \"-DCMAKE_BUILD_TYPE=Debug\", \"../.\" ], \"group\": \"build\", \"presentation\": { \"reveal\": \"always\", \"panel\": \"shared\", \"showReuseMessage\": false }, \"options\": { \"cwd\": \"${workspaceFolder}/build\" } }, { \"label\": \"Ninja Build\", \"type\": \"shell\", \"command\": \"ninja\", \"group\": { \"kind\": \"build\", \"isDefault\": true }, \"presentation\": { \"reveal\": \"always\", \"panel\": \"shared\", \"showReuseMessage\": false }, \"options\": { \"cwd\": \"${workspaceFolder}/build\", }, \"dependsOn\": [ \"CMake Generate Debug\" ], } ] } Pressing ctrl+shift+b will trigger the build. Since the Ninja Build task is depending on CMake Generate Debug it will run automatically before Ninja Build runs. Debugging To debug or launch the application we'll have to create the .vscode/launch.json configuration file. Here we can specify how VSCode can run the application when user press F5 or Ctrl+F5 . Create the .vscode/launch.json file: touch .vscode/launch.json Define the launch configuration within vscode/launch.json file: { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"cppdbg\", \"request\": \"launch\", \"name\": \"Launch Application\", \"program\": \"${workspaceRoot}/build/hello_world\", \"cwd\": \"${workspaceRoot}\", \"preLaunchTask\": \"${defaultBuildTask}\", } ] } Now when pressing F5 the application can be debugged, and will stop on any breakpoints in the code. Don't forget to test this and if all works well commit the changes using git. git add . && git commit -m \"chore: add tasks for building and launching the application\"","title":"2. Build System"},{"location":"2_build_system/#build-system","text":"To avoid having to manually invoke the clang compiler manually each time we want to build the project, as well as allowing dependencies to be specified regardless of which computer or operating system is used we'll set up cmake to generate a project and then use ninja to build. cmake use a file called CMakeLists.txt to determine which dependencies, input files, and outputs should be generated. We'll create a minimal CMakeLists.txt file to build our hello_world program using that instead. touch CMakeLists.txt Open CMakeLists.txt and type the following: cmake_minimum_required(VERSION 3.24) project(back_to_basics) # The path to clang might vary depending on system set(CMAKE_C_COMPILER /usr/bin/clang) # Use the c11 standard set(CMAKE_C_STANDARD 11) # Define the hello_world executable target add_executable(hello_world src/hello_world.c) Now use cmake to generate the Ninja project configuration and then build the project: mkdir build && cd build cmake -GNinja ../. ninja After runnig the previous commands a new hello_world executable has been generated try running it to ensure we still see the Hello, World! output being printed: ./hello_world Since we don't want to commit the build directory into git we'll add it to the ignore list. Open .gitignore file and replace all contents with the following: build/ To clean up from the manual build made earlier we can remove the old bin/ directory as well. cd .. && rm -rf bin Commit the changes using git: git add . && git commit -m \"feat: minimum cmake configuration to build hello_world\"","title":"Build System"},{"location":"2_build_system/#visual-studio-code","text":"It's recommended to install the C/C++ Extension Pack for Visual Studio Code before proceeding with setting up the building and debugging tasks. https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools-extension-pack. We can configure tasks to build and debug the application in Visual Studio Code. This will allow us to press F7 to build.","title":"Visual Studio Code"},{"location":"2_build_system/#building","text":"Start by creating the .vscode directory and a tasks.json file. mkdir .vscode && touch .vscode/tasks.json We'll populate the .vscode/tasks.json file with two tasks, one task for generating the ninja build configuration using cmake and one task to invoke ninja to build the project. { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"CMake Generate Debug\", \"type\": \"shell\", \"command\": \"cmake\", \"args\": [ \"-GNinja\", \"-DCMAKE_BUILD_TYPE=Debug\", \"../.\" ], \"group\": \"build\", \"presentation\": { \"reveal\": \"always\", \"panel\": \"shared\", \"showReuseMessage\": false }, \"options\": { \"cwd\": \"${workspaceFolder}/build\" } }, { \"label\": \"Ninja Build\", \"type\": \"shell\", \"command\": \"ninja\", \"group\": { \"kind\": \"build\", \"isDefault\": true }, \"presentation\": { \"reveal\": \"always\", \"panel\": \"shared\", \"showReuseMessage\": false }, \"options\": { \"cwd\": \"${workspaceFolder}/build\", }, \"dependsOn\": [ \"CMake Generate Debug\" ], } ] } Pressing ctrl+shift+b will trigger the build. Since the Ninja Build task is depending on CMake Generate Debug it will run automatically before Ninja Build runs.","title":"Building"},{"location":"2_build_system/#debugging","text":"To debug or launch the application we'll have to create the .vscode/launch.json configuration file. Here we can specify how VSCode can run the application when user press F5 or Ctrl+F5 . Create the .vscode/launch.json file: touch .vscode/launch.json Define the launch configuration within vscode/launch.json file: { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"cppdbg\", \"request\": \"launch\", \"name\": \"Launch Application\", \"program\": \"${workspaceRoot}/build/hello_world\", \"cwd\": \"${workspaceRoot}\", \"preLaunchTask\": \"${defaultBuildTask}\", } ] } Now when pressing F5 the application can be debugged, and will stop on any breakpoints in the code. Don't forget to test this and if all works well commit the changes using git. git add . && git commit -m \"chore: add tasks for building and launching the application\"","title":"Debugging"},{"location":"3_creating_a_window/","text":"Creating a Window Now it's time to move away from just plain terminal hello world and create a window. To display a window we'll be using the SDL2 library. Simple DirectMedia Layer is a cross-platform development library designed to provide low level access to audio, keyboard, mouse, joystick, and graphics hardware via OpenGL and Direct3D. It is used by video playback software, emulators, and popular games including Valve's award winning catalog and many Humble Bundle games. - https://github.com/libsdl-org/SDL Installing SDL2 Installing SDL2 is easy on most Linux distributions. most package repositories already contains the library. pacman -S sdl2 Replacing Hello World We'll start by removing the src/chello_world.c example code and instead create src/main.c this will be our entrypoint from now on, where the code starts executing when the user run our game. rm src/hello_world.c Create the new src/main.c file with empty main function: int main(int argc, char* argv[]) { return 0; } We'll also have to update our CMakeLists.txt to include SDL2 library and use our new src/main.c . First we'll remove the old hello_world executable. Just remove the line add_executable(hello_world src/hello_world.c) Next to tell cmake to find the SDL2 header files and library files add these lines to the CMakeLists.txt : find_package(SDL2 REQUIRED) include_directories(back_to_basics ${SDL2_INCLUDE_DIRS}) Finally add the game executable and associated source file: add_executable(back_to_basics src/main.c) target_link_libraries(back_to_basics ${SDL2_LIBRARIES}) Initializing SDL2 Video Subsystem SDL2 functionality is divided into various subsystems. The only one we're interested in for now is the VIDEO subsystem. Before using any features from the VIDEO subsystem we have to initialize it. Add the following lines to src/main.c : if (SDL_Init(SDL_INIT_VIDEO) < 0) { printf(\"failed initializing SDL2\\n\"); return -1; } We'll also ensure any resources allocated by SDL2 during initialization is properly freed before the application exits. Add the following at the end of main function before the return 0 statement. SDL_Quit(); Now our src/main.c file should look like this: int main(int argc, char* argv[]) { if (SDL_Init(SDL_INIT_VIDEO) < 0) { printf(\"failed initializing SDL2\\n\"); return -1; } SDL_Quit(); return 0; } Try compiling and running the application making sure there's no mistakes and the failed initializing SDL2 message doesn't appear. Creating the window Now finally it's time to create the window and make it stay open until the user choose to close it. Additionally we're going to ensure the window can be filled with a color. Start by creating a source file and associated header file to ensue the src/main.c file doesn't get too busy. Separating code into different files helps with maintenance and organization. Create src/game_window.h and src/game_window.c : touch src/game_window.h touch src/game_window.c game_window.h The initial code inside src/game_window.h will look like this: // game_window.h #ifndef GAME_WINDOW_INCLUDED #define GAME_WINDOW_INCLUDED #include <stdint.h> typedef struct GameWindow { int32_t window_width; int32_t window_height; int32_t pixel_buffer_width; int32_t pixel_buffer_height; uint8_t flags; uint8_t *pixels; struct GameWindowInternal* internal; } GameWindow; enum GameWindowFlags { GAME_WINDOW_FLAGS_NONE = 0, GAME_WINDOW_FLAGS_CLOSED = 1 << 0, }; GameWindow* game_window_create(); void game_window_destroy(GameWindow *game_window); void game_window_process_events(GameWindow *game_window); void game_window_surface_lock_pixels(GameWindow *game_window); void game_window_surface_unlock_and_update_pixels(GameWindow *game_window); #endif // GAME_WINDOW_INCLUDED Here we've defined the public struct for keeping track of the window state. There's a there's also a declaration of a struct for holding internal state to keep the SDL2 references contained to src/game_window.c file. That way we can choose to replace SDL2 in the future without having to modify any other parts of the code. Additionally there's a field and associated enum for holding flags this state is packed into an eight bit integer which will allow storing eight different states. The enum with state will just have the GAME_WINDOW_FLAGS_CLOSED state for now which will be used to indicate the window has been closed by the user. Finally there's five declared functions, these functions will be called from the src/main.c file to interact with the window. game_window.c Start by including the necessary header files and defining the GameWindowInternal struct . Add the following to the top of the src/game_window.c file: // game_window.c #include \"game_window.h\" #include <SDL2/SDL.h> typedef struct GameWindowInternal { SDL_Window* window_handle; SDL_Surface* surface; } GameWindowInternal; Next for creating our window we'll define the game_window_create function. This function will be responsible for allocating the memory for our GameWindow struct and then using SDL2 to create our window. It will also populate the struct with some good initial values. GameWindow* game_window_create(const char* title, int width, int height) { // Tell SDL our window should be resizeable uint32_t window_flags = SDL_WINDOW_RESIZABLE; // Create the window passing our desired title, position, size, and flags. SDL_Window *sdl_window = SDL_CreateWindow(title, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, width, height, window_flags); if (!sdl_window) { printf(\"failed to create window\\n\"); return 0; } // Allocate memory for the GameWindow and GameWindowInternal structs uintptr_t window_and_internal_size = sizeof(GameWindow) + sizeof(GameWindowInternal); GameWindow* game_window = malloc(window_and_internal_size); game_window->internal = (GameWindowInternal*)(game_window + 1); // Assign initial values to the struct game_window->internal->window_handle = sdl_window; game_window->internal->surface = 0; game_window->window_width = width; game_window->window_height = height; game_window->pixel_buffer_width = 0; game_window->pixel_buffer_height = 0; game_window->pixels = 0; game_window->flags = GAME_WINDOW_FLAGS_NONE; // Return the pointer to our GameWindow struct. return game_window; } Many times in programming symmetry is applied, so when we add a function to create something we'll also want to be able to destroy or free that same thing. Add the game_window_destroy function to src/game_window.c : void game_window_destroy(GameWindow* game_window) { // Tell SDL to destroy our window SDL_DestroyWindow(game_window->internal->window_handle); game_window->internal->window_handle = 0; // Free the memory we allocated for the GameWindow struct free(game_window); } Next up is processing window events. These events is generated by SDL2 and should be processed regularly. There's multiple different kind of events but we're only interested in knowing if the user want to close the window or if the window changes size for now. Add the following function to src/game_window.c : void game_window_process_events(GameWindow* game_window) { // Use SDL_PollEvent in a loop to retrieve events until there's no more events available. SDL_Event event; while(SDL_PollEvent(&event)) { switch(event.type) { case SDL_WINDOWEVENT: if (event.window.event == SDL_WINDOWEVENT_SHOWN) { game_window_update_size(game_window); } if (event.window.event == SDL_WINDOWEVENT_RESIZED) { game_window_update_size(game_window); } break; case SDL_QUIT: game_window->flags |= GAME_WINDOW_FLAGS_CLOSED; break; } } } SDL_PollEvent will look in the queue of events and retrieve the first one and remove it from the queue. We do this in a loop to retrieve all the events until there's none left. This should happen regularly because otherwise the events queue will fill up and window may become unresponsive. We're using a switch statement to determine what type of event was retrieved. If it was a SDL_WINDOWEVENT we'll check if it was the window being shown or resized, if it was a SDL_QUIT event we'll update the game_window->flags field to indicate the window was closed. Above the game_window_process_events function we should add the game_window_update_size function. This function isn't declared in the src/game_window.h header file so it needs to be defined before being used. The function is responsible for reading and updating the window size as well as the underlying pixel buffer size these two may differ due to the screen DPI. Add the function above game_window_process_events : void game_window_update_size(GameWindow* window) { SDL_GetWindowSize(window->internal->window_handle, &window->window_width, &window->window_height); SDL_Renderer* renderer = SDL_GetRenderer(window->internal->window_handle); SDL_GetRendererOutputSize(renderer, &window->pixel_buffer_width, &window->pixel_buffer_height); } Finally to modify the buffer of pixels we'll have to retrieve a pointer to the memory where it's stored. Aditionally it's best to 'lock' the buffer, this is not applicable to all configurations but doesn't hurt much to do it. Add the following two functions for locking and unlocking the buffer to the end of src/game_window.c : void game_window_surface_lock_pixels(GameWindow* game_window) { // Retrieve pointer to SDL_Surface SDL_Surface *surface = SDL_GetWindowSurface(game_window->internal->window_handle); // Lock the surface SDL_LockSurface(surface); // Assign internal state as well as the pixels pointer game_window->internal->surface = surface; game_window->pixels = surface->pixels; } void game_window_surface_unlock_and_update_pixels(GameWindow* game_window) { // Reset the pixels pointer to prevent accidentally writing to it while // surface isn't locked. game_window->pixels = 0; // Unlock the surface SDL_UnlockSurface(game_window->internal->surface); // Tell SDL2 to redraw the window with content from the pixels buffer SDL_UpdateWindowSurface(game_window->internal->window_handle); } Now the src/game_window.c file is done and we just have to modify src/main.c to call the functions we've just created. main.c Since all the window logic is nicely encapsulated inside src/game_window.c we just have to make pretty minor modifications to the src/main.c file. Add the following content to src/main.c between the SDL_Init(SDL_INIT_VIDEO) and SDL_Quit() calls: GameWindow* game_window = game_window_create(\"back_to_basics\", 680, 480); // Keep running while the window is open while ((game_window->flags & GAME_WINDOW_FLAGS_CLOSED) == 0) { // Process the window events game_window_process_events(game_window); // Lock the window surface pixel buffer game_window_surface_lock_pixels(game_window); // Write blue color to every pixel uint32_t *pixels_32bpp = (uint32_t *)game_window->pixels; for (int y = 0; y < game_window->pixel_buffer_height; y++) { uint32_t row = y * game_window->pixel_buffer_width; for (int x = 0; x < game_window->pixel_buffer_width; x++) { pixels_32bpp[x + row] = 0xff0000ff; } } // Unlock the pixel buffer and update window game_window_surface_unlock_and_update_pixels(game_window); // Wait 10 milliseconds so the CPU isn't working all the time SDL_Delay(10); } Compiling and running the code now should display a window filled with blue color. Don't forget to commit the changes using git after verifying all the code is working properly. Full diff for this chapter modified .vscode/launch.json @@ -6,7 +6,7 @@ \"type\": \"cppdbg\", \"request\": \"launch\", \"name\": \"Launch Application\", - \"program\": \"${workspaceRoot}/build/hello_world\", + \"program\": \"${workspaceRoot}/build/back_to_basics\", \"cwd\": \"${workspaceRoot}\", \"preLaunchTask\": \"${defaultBuildTask}\", } modified CMakeLists.txt @@ -4,4 +4,8 @@ project(back_to_basics) set(CMAKE_C_COMPILER /usr/bin/clang) set(CMAKE_C_STANDARD 11) -add_executable(hello_world src/hello_world.c) +find_package(SDL2 REQUIRED) +include_directories(back_to_basics ${SDL2_INCLUDE_DIRS}) + +add_executable(back_to_basics src/main.c src/game_window.c) +target_link_libraries(back_to_basics ${SDL2_LIBRARIES}) new file src/game_window.c @@ -0,0 +1,104 @@ +// game_window.c + +#include \"game_window.h\" + +#include <SDL2/SDL.h> +typedef struct GameWindowInternal { + SDL_Window* window_handle; + SDL_Surface* surface; +} GameWindowInternal; + +void game_window_update_size(GameWindow* window) +{ + SDL_GetWindowSize(window->internal->window_handle, + &window->window_width, + &window->window_height); + + SDL_Renderer* renderer = + SDL_GetRenderer(window->internal->window_handle); + + SDL_GetRendererOutputSize(renderer, + &window->pixel_buffer_width, + &window->pixel_buffer_height); +} + +GameWindow* game_window_create(const char* title, int width, int height) +{ + uint32_t window_flags = SDL_WINDOW_RESIZABLE; + SDL_Window *sdl_window = SDL_CreateWindow(title, + SDL_WINDOWPOS_CENTERED, + SDL_WINDOWPOS_CENTERED, + width, height, + window_flags); + + if (!sdl_window) + { + printf(\"failed to create window\\n\"); + return 0; + } + + uintptr_t window_and_internal_size = + sizeof(GameWindow) + sizeof(GameWindowInternal); + GameWindow* game_window = malloc(window_and_internal_size); + game_window->internal = (GameWindowInternal*)(game_window + 1); + game_window->internal->window_handle = sdl_window; + game_window->internal->surface = 0; + + game_window->window_width = width; + game_window->window_height = height; + game_window->pixel_buffer_width = 0; + game_window->pixel_buffer_height = 0; + game_window->pixels = 0; + game_window->flags = GAME_WINDOW_FLAGS_NONE; + + return game_window; +} + +void game_window_destroy(GameWindow* game_window) +{ + SDL_DestroyWindow(game_window->internal->window_handle); + game_window->internal->window_handle = 0; + + free(game_window); +} + +void game_window_process_events(GameWindow* game_window) +{ + SDL_Event event; + while(SDL_PollEvent(&event)) + { + switch(event.type) + { + case SDL_WINDOWEVENT: + if (event.window.event == SDL_WINDOWEVENT_SHOWN) { + game_window_update_size(game_window); + } + if (event.window.event == SDL_WINDOWEVENT_RESIZED) { + game_window_update_size(game_window); + } + break; + case SDL_QUIT: + game_window->flags |= GAME_WINDOW_FLAGS_CLOSED; + break; + } + } +} + +void game_window_surface_lock_pixels(GameWindow* game_window) +{ + SDL_Surface *surface = + SDL_GetWindowSurface(game_window->internal->window_handle); + + SDL_LockSurface(surface); + + game_window->internal->surface = surface; + game_window->pixels = surface->pixels; +} + +void game_window_surface_unlock_and_update_pixels(GameWindow* game_window) +{ + game_window->pixels = 0; + + SDL_UnlockSurface(game_window->internal->surface); + SDL_UpdateWindowSurface(game_window->internal->window_handle); +} new file src/game_window.h @@ -0,0 +1,30 @@ +// game_window.h + +#ifndef GAME_WINDOW_INCLUDED +#define GAME_WINDOW_INCLUDED + +#include <stdint.h> + +typedef struct GameWindow { + int32_t window_width; + int32_t window_height; + int32_t pixel_buffer_width; + int32_t pixel_buffer_height; + uint8_t flags; + uint8_t *pixels; + + struct GameWindowInternal* internal; +} GameWindow; + +enum GameWindowFlags { + GAME_WINDOW_FLAGS_NONE = 0, + GAME_WINDOW_FLAGS_CLOSED = 1 << 0, +}; + +GameWindow* game_window_create(); +void game_window_destroy(GameWindow *game_window); +void game_window_process_events(GameWindow *game_window); +void game_window_surface_lock_pixels(GameWindow *game_window); +void game_window_surface_unlock_and_update_pixels(GameWindow *game_window); + +#endif // GAME_WINDOW_INCLUDED \\ No newline at end of file deleted src/hello_world.c @@ -1,8 +0,0 @@ -#include <stdio.h> - -int main(int argc, char* argv[]) -{ - printf(\"Hello, World!\\n\"); - - return 0; -} new file src/main.c @@ -0,0 +1,42 @@ +// main.c + +#include <SDL2/SDL.h> + +#include \"game_window.h\" + +int main(int argc, char* argv[]) +{ + if (SDL_Init(SDL_INIT_VIDEO) < 0) + { + printf(\"failed initializing SDL2\\n\"); + return -1; + } + + GameWindow* game_window = + game_window_create(\"back_to_basics\", 680, 480); + + while ((game_window->flags & GAME_WINDOW_FLAGS_CLOSED) == 0) + { + game_window_process_events(game_window); + + game_window_surface_lock_pixels(game_window); + + uint32_t *pixels_32bpp = (uint32_t *)game_window->pixels; + for (int y = 0; y < game_window->pixel_buffer_height; y++) + { + uint32_t row = y * game_window->pixel_buffer_width; + for (int x = 0; x < game_window->pixel_buffer_width; x++) + { + pixels_32bpp[x + row] = 0xff0000ff; + } + } + + game_window_surface_unlock_and_update_pixels(game_window); + + SDL_Delay(10); + } + + SDL_Quit(); + + return 0; +}","title":"3. Creating a Window"},{"location":"3_creating_a_window/#creating-a-window","text":"Now it's time to move away from just plain terminal hello world and create a window. To display a window we'll be using the SDL2 library. Simple DirectMedia Layer is a cross-platform development library designed to provide low level access to audio, keyboard, mouse, joystick, and graphics hardware via OpenGL and Direct3D. It is used by video playback software, emulators, and popular games including Valve's award winning catalog and many Humble Bundle games. - https://github.com/libsdl-org/SDL","title":"Creating a Window"},{"location":"3_creating_a_window/#installing-sdl2","text":"Installing SDL2 is easy on most Linux distributions. most package repositories already contains the library. pacman -S sdl2","title":"Installing SDL2"},{"location":"3_creating_a_window/#replacing-hello-world","text":"We'll start by removing the src/chello_world.c example code and instead create src/main.c this will be our entrypoint from now on, where the code starts executing when the user run our game. rm src/hello_world.c Create the new src/main.c file with empty main function: int main(int argc, char* argv[]) { return 0; } We'll also have to update our CMakeLists.txt to include SDL2 library and use our new src/main.c . First we'll remove the old hello_world executable. Just remove the line add_executable(hello_world src/hello_world.c) Next to tell cmake to find the SDL2 header files and library files add these lines to the CMakeLists.txt : find_package(SDL2 REQUIRED) include_directories(back_to_basics ${SDL2_INCLUDE_DIRS}) Finally add the game executable and associated source file: add_executable(back_to_basics src/main.c) target_link_libraries(back_to_basics ${SDL2_LIBRARIES})","title":"Replacing Hello World"},{"location":"3_creating_a_window/#initializing-sdl2-video-subsystem","text":"SDL2 functionality is divided into various subsystems. The only one we're interested in for now is the VIDEO subsystem. Before using any features from the VIDEO subsystem we have to initialize it. Add the following lines to src/main.c : if (SDL_Init(SDL_INIT_VIDEO) < 0) { printf(\"failed initializing SDL2\\n\"); return -1; } We'll also ensure any resources allocated by SDL2 during initialization is properly freed before the application exits. Add the following at the end of main function before the return 0 statement. SDL_Quit(); Now our src/main.c file should look like this: int main(int argc, char* argv[]) { if (SDL_Init(SDL_INIT_VIDEO) < 0) { printf(\"failed initializing SDL2\\n\"); return -1; } SDL_Quit(); return 0; } Try compiling and running the application making sure there's no mistakes and the failed initializing SDL2 message doesn't appear.","title":"Initializing SDL2 Video Subsystem"},{"location":"3_creating_a_window/#creating-the-window","text":"Now finally it's time to create the window and make it stay open until the user choose to close it. Additionally we're going to ensure the window can be filled with a color. Start by creating a source file and associated header file to ensue the src/main.c file doesn't get too busy. Separating code into different files helps with maintenance and organization. Create src/game_window.h and src/game_window.c : touch src/game_window.h touch src/game_window.c","title":"Creating the window"},{"location":"3_creating_a_window/#game_windowh","text":"The initial code inside src/game_window.h will look like this: // game_window.h #ifndef GAME_WINDOW_INCLUDED #define GAME_WINDOW_INCLUDED #include <stdint.h> typedef struct GameWindow { int32_t window_width; int32_t window_height; int32_t pixel_buffer_width; int32_t pixel_buffer_height; uint8_t flags; uint8_t *pixels; struct GameWindowInternal* internal; } GameWindow; enum GameWindowFlags { GAME_WINDOW_FLAGS_NONE = 0, GAME_WINDOW_FLAGS_CLOSED = 1 << 0, }; GameWindow* game_window_create(); void game_window_destroy(GameWindow *game_window); void game_window_process_events(GameWindow *game_window); void game_window_surface_lock_pixels(GameWindow *game_window); void game_window_surface_unlock_and_update_pixels(GameWindow *game_window); #endif // GAME_WINDOW_INCLUDED Here we've defined the public struct for keeping track of the window state. There's a there's also a declaration of a struct for holding internal state to keep the SDL2 references contained to src/game_window.c file. That way we can choose to replace SDL2 in the future without having to modify any other parts of the code. Additionally there's a field and associated enum for holding flags this state is packed into an eight bit integer which will allow storing eight different states. The enum with state will just have the GAME_WINDOW_FLAGS_CLOSED state for now which will be used to indicate the window has been closed by the user. Finally there's five declared functions, these functions will be called from the src/main.c file to interact with the window.","title":"game_window.h"},{"location":"3_creating_a_window/#game_windowc","text":"Start by including the necessary header files and defining the GameWindowInternal struct . Add the following to the top of the src/game_window.c file: // game_window.c #include \"game_window.h\" #include <SDL2/SDL.h> typedef struct GameWindowInternal { SDL_Window* window_handle; SDL_Surface* surface; } GameWindowInternal; Next for creating our window we'll define the game_window_create function. This function will be responsible for allocating the memory for our GameWindow struct and then using SDL2 to create our window. It will also populate the struct with some good initial values. GameWindow* game_window_create(const char* title, int width, int height) { // Tell SDL our window should be resizeable uint32_t window_flags = SDL_WINDOW_RESIZABLE; // Create the window passing our desired title, position, size, and flags. SDL_Window *sdl_window = SDL_CreateWindow(title, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, width, height, window_flags); if (!sdl_window) { printf(\"failed to create window\\n\"); return 0; } // Allocate memory for the GameWindow and GameWindowInternal structs uintptr_t window_and_internal_size = sizeof(GameWindow) + sizeof(GameWindowInternal); GameWindow* game_window = malloc(window_and_internal_size); game_window->internal = (GameWindowInternal*)(game_window + 1); // Assign initial values to the struct game_window->internal->window_handle = sdl_window; game_window->internal->surface = 0; game_window->window_width = width; game_window->window_height = height; game_window->pixel_buffer_width = 0; game_window->pixel_buffer_height = 0; game_window->pixels = 0; game_window->flags = GAME_WINDOW_FLAGS_NONE; // Return the pointer to our GameWindow struct. return game_window; } Many times in programming symmetry is applied, so when we add a function to create something we'll also want to be able to destroy or free that same thing. Add the game_window_destroy function to src/game_window.c : void game_window_destroy(GameWindow* game_window) { // Tell SDL to destroy our window SDL_DestroyWindow(game_window->internal->window_handle); game_window->internal->window_handle = 0; // Free the memory we allocated for the GameWindow struct free(game_window); } Next up is processing window events. These events is generated by SDL2 and should be processed regularly. There's multiple different kind of events but we're only interested in knowing if the user want to close the window or if the window changes size for now. Add the following function to src/game_window.c : void game_window_process_events(GameWindow* game_window) { // Use SDL_PollEvent in a loop to retrieve events until there's no more events available. SDL_Event event; while(SDL_PollEvent(&event)) { switch(event.type) { case SDL_WINDOWEVENT: if (event.window.event == SDL_WINDOWEVENT_SHOWN) { game_window_update_size(game_window); } if (event.window.event == SDL_WINDOWEVENT_RESIZED) { game_window_update_size(game_window); } break; case SDL_QUIT: game_window->flags |= GAME_WINDOW_FLAGS_CLOSED; break; } } } SDL_PollEvent will look in the queue of events and retrieve the first one and remove it from the queue. We do this in a loop to retrieve all the events until there's none left. This should happen regularly because otherwise the events queue will fill up and window may become unresponsive. We're using a switch statement to determine what type of event was retrieved. If it was a SDL_WINDOWEVENT we'll check if it was the window being shown or resized, if it was a SDL_QUIT event we'll update the game_window->flags field to indicate the window was closed. Above the game_window_process_events function we should add the game_window_update_size function. This function isn't declared in the src/game_window.h header file so it needs to be defined before being used. The function is responsible for reading and updating the window size as well as the underlying pixel buffer size these two may differ due to the screen DPI. Add the function above game_window_process_events : void game_window_update_size(GameWindow* window) { SDL_GetWindowSize(window->internal->window_handle, &window->window_width, &window->window_height); SDL_Renderer* renderer = SDL_GetRenderer(window->internal->window_handle); SDL_GetRendererOutputSize(renderer, &window->pixel_buffer_width, &window->pixel_buffer_height); } Finally to modify the buffer of pixels we'll have to retrieve a pointer to the memory where it's stored. Aditionally it's best to 'lock' the buffer, this is not applicable to all configurations but doesn't hurt much to do it. Add the following two functions for locking and unlocking the buffer to the end of src/game_window.c : void game_window_surface_lock_pixels(GameWindow* game_window) { // Retrieve pointer to SDL_Surface SDL_Surface *surface = SDL_GetWindowSurface(game_window->internal->window_handle); // Lock the surface SDL_LockSurface(surface); // Assign internal state as well as the pixels pointer game_window->internal->surface = surface; game_window->pixels = surface->pixels; } void game_window_surface_unlock_and_update_pixels(GameWindow* game_window) { // Reset the pixels pointer to prevent accidentally writing to it while // surface isn't locked. game_window->pixels = 0; // Unlock the surface SDL_UnlockSurface(game_window->internal->surface); // Tell SDL2 to redraw the window with content from the pixels buffer SDL_UpdateWindowSurface(game_window->internal->window_handle); } Now the src/game_window.c file is done and we just have to modify src/main.c to call the functions we've just created.","title":"game_window.c"},{"location":"3_creating_a_window/#mainc","text":"Since all the window logic is nicely encapsulated inside src/game_window.c we just have to make pretty minor modifications to the src/main.c file. Add the following content to src/main.c between the SDL_Init(SDL_INIT_VIDEO) and SDL_Quit() calls: GameWindow* game_window = game_window_create(\"back_to_basics\", 680, 480); // Keep running while the window is open while ((game_window->flags & GAME_WINDOW_FLAGS_CLOSED) == 0) { // Process the window events game_window_process_events(game_window); // Lock the window surface pixel buffer game_window_surface_lock_pixels(game_window); // Write blue color to every pixel uint32_t *pixels_32bpp = (uint32_t *)game_window->pixels; for (int y = 0; y < game_window->pixel_buffer_height; y++) { uint32_t row = y * game_window->pixel_buffer_width; for (int x = 0; x < game_window->pixel_buffer_width; x++) { pixels_32bpp[x + row] = 0xff0000ff; } } // Unlock the pixel buffer and update window game_window_surface_unlock_and_update_pixels(game_window); // Wait 10 milliseconds so the CPU isn't working all the time SDL_Delay(10); } Compiling and running the code now should display a window filled with blue color. Don't forget to commit the changes using git after verifying all the code is working properly.","title":"main.c"},{"location":"3_creating_a_window/#full-diff-for-this-chapter","text":"modified .vscode/launch.json @@ -6,7 +6,7 @@ \"type\": \"cppdbg\", \"request\": \"launch\", \"name\": \"Launch Application\", - \"program\": \"${workspaceRoot}/build/hello_world\", + \"program\": \"${workspaceRoot}/build/back_to_basics\", \"cwd\": \"${workspaceRoot}\", \"preLaunchTask\": \"${defaultBuildTask}\", } modified CMakeLists.txt @@ -4,4 +4,8 @@ project(back_to_basics) set(CMAKE_C_COMPILER /usr/bin/clang) set(CMAKE_C_STANDARD 11) -add_executable(hello_world src/hello_world.c) +find_package(SDL2 REQUIRED) +include_directories(back_to_basics ${SDL2_INCLUDE_DIRS}) + +add_executable(back_to_basics src/main.c src/game_window.c) +target_link_libraries(back_to_basics ${SDL2_LIBRARIES}) new file src/game_window.c @@ -0,0 +1,104 @@ +// game_window.c + +#include \"game_window.h\" + +#include <SDL2/SDL.h> +typedef struct GameWindowInternal { + SDL_Window* window_handle; + SDL_Surface* surface; +} GameWindowInternal; + +void game_window_update_size(GameWindow* window) +{ + SDL_GetWindowSize(window->internal->window_handle, + &window->window_width, + &window->window_height); + + SDL_Renderer* renderer = + SDL_GetRenderer(window->internal->window_handle); + + SDL_GetRendererOutputSize(renderer, + &window->pixel_buffer_width, + &window->pixel_buffer_height); +} + +GameWindow* game_window_create(const char* title, int width, int height) +{ + uint32_t window_flags = SDL_WINDOW_RESIZABLE; + SDL_Window *sdl_window = SDL_CreateWindow(title, + SDL_WINDOWPOS_CENTERED, + SDL_WINDOWPOS_CENTERED, + width, height, + window_flags); + + if (!sdl_window) + { + printf(\"failed to create window\\n\"); + return 0; + } + + uintptr_t window_and_internal_size = + sizeof(GameWindow) + sizeof(GameWindowInternal); + GameWindow* game_window = malloc(window_and_internal_size); + game_window->internal = (GameWindowInternal*)(game_window + 1); + game_window->internal->window_handle = sdl_window; + game_window->internal->surface = 0; + + game_window->window_width = width; + game_window->window_height = height; + game_window->pixel_buffer_width = 0; + game_window->pixel_buffer_height = 0; + game_window->pixels = 0; + game_window->flags = GAME_WINDOW_FLAGS_NONE; + + return game_window; +} + +void game_window_destroy(GameWindow* game_window) +{ + SDL_DestroyWindow(game_window->internal->window_handle); + game_window->internal->window_handle = 0; + + free(game_window); +} + +void game_window_process_events(GameWindow* game_window) +{ + SDL_Event event; + while(SDL_PollEvent(&event)) + { + switch(event.type) + { + case SDL_WINDOWEVENT: + if (event.window.event == SDL_WINDOWEVENT_SHOWN) { + game_window_update_size(game_window); + } + if (event.window.event == SDL_WINDOWEVENT_RESIZED) { + game_window_update_size(game_window); + } + break; + case SDL_QUIT: + game_window->flags |= GAME_WINDOW_FLAGS_CLOSED; + break; + } + } +} + +void game_window_surface_lock_pixels(GameWindow* game_window) +{ + SDL_Surface *surface = + SDL_GetWindowSurface(game_window->internal->window_handle); + + SDL_LockSurface(surface); + + game_window->internal->surface = surface; + game_window->pixels = surface->pixels; +} + +void game_window_surface_unlock_and_update_pixels(GameWindow* game_window) +{ + game_window->pixels = 0; + + SDL_UnlockSurface(game_window->internal->surface); + SDL_UpdateWindowSurface(game_window->internal->window_handle); +} new file src/game_window.h @@ -0,0 +1,30 @@ +// game_window.h + +#ifndef GAME_WINDOW_INCLUDED +#define GAME_WINDOW_INCLUDED + +#include <stdint.h> + +typedef struct GameWindow { + int32_t window_width; + int32_t window_height; + int32_t pixel_buffer_width; + int32_t pixel_buffer_height; + uint8_t flags; + uint8_t *pixels; + + struct GameWindowInternal* internal; +} GameWindow; + +enum GameWindowFlags { + GAME_WINDOW_FLAGS_NONE = 0, + GAME_WINDOW_FLAGS_CLOSED = 1 << 0, +}; + +GameWindow* game_window_create(); +void game_window_destroy(GameWindow *game_window); +void game_window_process_events(GameWindow *game_window); +void game_window_surface_lock_pixels(GameWindow *game_window); +void game_window_surface_unlock_and_update_pixels(GameWindow *game_window); + +#endif // GAME_WINDOW_INCLUDED \\ No newline at end of file deleted src/hello_world.c @@ -1,8 +0,0 @@ -#include <stdio.h> - -int main(int argc, char* argv[]) -{ - printf(\"Hello, World!\\n\"); - - return 0; -} new file src/main.c @@ -0,0 +1,42 @@ +// main.c + +#include <SDL2/SDL.h> + +#include \"game_window.h\" + +int main(int argc, char* argv[]) +{ + if (SDL_Init(SDL_INIT_VIDEO) < 0) + { + printf(\"failed initializing SDL2\\n\"); + return -1; + } + + GameWindow* game_window = + game_window_create(\"back_to_basics\", 680, 480); + + while ((game_window->flags & GAME_WINDOW_FLAGS_CLOSED) == 0) + { + game_window_process_events(game_window); + + game_window_surface_lock_pixels(game_window); + + uint32_t *pixels_32bpp = (uint32_t *)game_window->pixels; + for (int y = 0; y < game_window->pixel_buffer_height; y++) + { + uint32_t row = y * game_window->pixel_buffer_width; + for (int x = 0; x < game_window->pixel_buffer_width; x++) + { + pixels_32bpp[x + row] = 0xff0000ff; + } + } + + game_window_surface_unlock_and_update_pixels(game_window); + + SDL_Delay(10); + } + + SDL_Quit(); + + return 0; +}","title":"Full diff for this chapter"},{"location":"4_manipulating_pixels/","text":"Manipulating Pixels In the previous chapter we created a window and filled it with blue color. This works but it's cumbersome to index the correct location in the buffer as well as defining the color as a 32-bit integer. In this chapter we will look at creating another source file which will make all of that a lot easier. Paving the way to finally make some triangles appear. Creating the Renderer To keep the src/main.c file clean all the code related to rendering pixels will be inside src/renderer.c file. Let's create that file and associated header file. touch src/renderer.h touch src/renderer.c Initially the renderer will contain some macros to help define colors more easily, as well as indexing and writing pixels to the pixels byte array. To demonstrate this functionality we'll also add a function for filling the window with a color and filling a rectangle (subset of the window) with a color. renderer.h Start by filling in the header guard defines this is common practice for all header files to prevent them from being included every time: // renderer.h #ifndef RENDERER_INCLUDED #define RENDERER_INCLUDED // TODO: Declarations goes here #endif // RENDERER_INCLUDED Now replace the TODO: Declarations goes here comment with the following struct declaration. This struct will be used to pass information about the pixel buffer we're rendering into to the rendering. This helps keep the number of arguments we need to pass into macros and functions to a minimum. We'll also add a helper function for creating instances of this struct: typedef struct renderer_target_buffer { int32_t width; int32_t height; int32_t bytes_per_pixel; uint8_t* pixels; } renderer_target_buffer; renderer_target_buffer renderer_create_target_buffer(int32_t width, int32_t height, int32_t bytes_per_pixel, uint8_t* pixels); Declare the renderer_rect struct below the renderer_target_buffer struct declaration: typedef struct renderer_rect { int32_t x; int32_t y; int32_t w; int32_t h; } renderer_rect; Add the following macros below the renderer_rect struct. These macros help pack 3 or four channel color values into a single 32 bit integer, as well as indexing the pixel buffer by offset or x,y coordinates: // Pack 3 color bytes into one uint32 #define PackColorRGB(r, g, b) (r & 0xff) << 16 | (g & 0xff) << 8 | (b & 0xff) // Pack 4 color bytes into one uint32 #define PackColorRGBA(r, g, b, a) (a & 0xff) << 24 | PackColorRGB(r, g, b) // Index pixel at x, y coordinates within renderer_target_buffer target #define IndexPixel(x, y, target) (x + y * target.width) * target.bytes_per_pixel // Put pixel at offset into target #define PutPixelByteOffset(target, offset, color) *(uint32_t *)(target.pixels + offset) = color // Put pixel at x,y into target #define PutPixelXY(target, x, y, color) PutPixelByteOffset(target, IndexPixel(x, y, target), color) Below the macro definitions we can add the function declarations. We'll add three functions for now; one to help create the renderer_target_buffer structure and the two others to fill entire window or a part of the window with desired color: renderer_target_buffer renderer_create_target_buffer(int32_t width, int32_t height, int32_t bytes_per_pixel, uint8_t* pixels); void renderer_fill(renderer_target_buffer buffer, uint32_t color); void renderer_fill_rect(renderer_target_buffer buffer, renderer_rect rect, uint32_t color); renderer.c The implementation of src/renderer.c will be fairily straight forward because of the macros and structure we've defined in the header. Put the following content inside the src/renderer.c file: // renderer.c #include <stdint.h> #include \"renderer.h\" renderer_target_buffer renderer_create_target_buffer(int32_t width, int32_t height, int32_t bytes_per_pixel, uint8_t *pixels) { renderer_target_buffer target = { width, height, bytes_per_pixel, pixels }; return target; } void renderer_fill(renderer_target_buffer buffer, uint32_t color) { uint32_t fill_until = buffer.width * buffer.height * buffer.bytes_per_pixel; uint32_t per_pixel_add = buffer.bytes_per_pixel; for (int offset = 0; offset < fill_until; offset += per_pixel_add) { PutPixelByteOffset(buffer, offset, color); } } void renderer_fill_rect(renderer_target_buffer buffer, renderer_rect rect, uint32_t color) { for (int y = rect.y; y < rect.y + rect.h; y++) { for(int x = rect.x; x < rect.x + rect.w; x++) { PutPixelXY(buffer, x, y, color); } } } Beware, there's no clipping implemented yet so passing in rectangles which goes outside the available pixel buffer space will cause segmentation faults or other memory related errors. Testing We'll make some changes to src/main.c to test the new src/renderer.c implementation. Filling the window with a color like before as well as putting some colored squares in each corner of the window. Update src/main.c with the following, put this code between the game_window_surface_lock_pixels(game_window); and game_window_surface_unlock_and_update_pixels(game_window); lines: int32_t bytes_per_pixel = 4; renderer_target_buffer pixel_buffer = renderer_create_target_buffer(game_window->pixel_buffer_width, game_window->pixel_buffer_height, bytes_per_pixel, game_window->pixels); renderer_fill(pixel_buffer, PackColorRGB(0, 0, 255)); if (game_window->pixel_buffer_width != 0) { renderer_rect top_left = { 0, 0, 32, 32 }; renderer_rect top_right = { pixel_buffer.width - 32, 0, 32, 32 }; renderer_rect bottom_left = { 0, pixel_buffer.height - 32, 32, 32 }; renderer_rect bottom_right = { pixel_buffer.width - 32, pixel_buffer.height - 32, 32, 32 }; renderer_fill_rect(pixel_buffer, top_left, PackColorRGB(255, 0, 0)); renderer_fill_rect(pixel_buffer, top_right, PackColorRGB(0, 255, 0)); renderer_fill_rect(pixel_buffer, bottom_left, PackColorRGB(0, 255, 255)); renderer_fill_rect(pixel_buffer, bottom_right, PackColorRGB(255, 255, 0)); } Don't forget to include the src/renderer.h file at the top of src/main.c as well: #include \"renderer.h\" Now all that's left to do is updating the CMakeLists.txt to include src/renderer.c when building the application. add_executable(back_to_basics src/main.c src/game_window.c src/renderer.c) Now try to build the application and if everything was alright observe the results, it should look like this: Full diff for this chapter modified CMakeLists.txt @@ -7,5 +7,5 @@ set(CMAKE_C_STANDARD 11) find_package(SDL2 REQUIRED) include_directories(back_to_basics ${SDL2_INCLUDE_DIRS}) -add_executable(back_to_basics src/main.c src/game_window.c) +add_executable(back_to_basics src/main.c src/game_window.c src/renderer.c) target_link_libraries(back_to_basics ${SDL2_LIBRARIES}) modified src/main.c @@ -3,6 +3,7 @@ #include <SDL2/SDL.h> #include \"game_window.h\" +#include \"renderer.h\" int main(int argc, char* argv[]) { @@ -21,14 +22,39 @@ int main(int argc, char* argv[]) game_window_surface_lock_pixels(game_window); - uint32_t *pixels_32bpp = (uint32_t *)game_window->pixels; - for (int y = 0; y < game_window->pixel_buffer_height; y++) + int32_t bytes_per_pixel = 4; + renderer_target_buffer pixel_buffer = + renderer_create_target_buffer(game_window->pixel_buffer_width, game_window->pixel_buffer_height, bytes_per_pixel, game_window->pixels); + + renderer_fill(pixel_buffer, PackColorRGB(0, 0, 255)); + + if (game_window->pixel_buffer_width != 0) { - uint32_t row = y * game_window->pixel_buffer_width; - for (int x = 0; x < game_window->pixel_buffer_width; x++) - { - pixels_32bpp[x + row] = 0xff0000ff; - } + renderer_rect top_left = { + 0, 0, 32, 32 + }; + + renderer_rect top_right = { + pixel_buffer.width - 32, + 0, 32, 32 + }; + + renderer_rect bottom_left = { + 0, + pixel_buffer.height - 32, + 32, 32 + }; + + renderer_rect bottom_right = { + pixel_buffer.width - 32, + pixel_buffer.height - 32, + 32, 32 + }; + + renderer_fill_rect(pixel_buffer, top_left, PackColorRGB(255, 0, 0)); + renderer_fill_rect(pixel_buffer, top_right, PackColorRGB(0, 255, 0)); + renderer_fill_rect(pixel_buffer, bottom_left, PackColorRGB(0, 255, 255)); + renderer_fill_rect(pixel_buffer, bottom_right, PackColorRGB(255, 255, 0)); } game_window_surface_unlock_and_update_pixels(game_window); new file src/renderer.c @@ -0,0 +1,37 @@ +// renderer.c + +#include <stdint.h> +#include \"renderer.h\" + +renderer_target_buffer +renderer_create_target_buffer(int32_t width, int32_t height, int32_t bytes_per_pixel, uint8_t *pixels) +{ + renderer_target_buffer target = { + width, height, bytes_per_pixel, pixels + }; + + return target; +} + +void +renderer_fill(renderer_target_buffer buffer, uint32_t color) +{ + uint32_t fill_until = buffer.width * buffer.height * buffer.bytes_per_pixel; + uint32_t per_pixel_add = buffer.bytes_per_pixel; + for (int offset = 0; offset < fill_until; offset += per_pixel_add) + { + PutPixelByteOffset(buffer, offset, color); + } +} + +void +renderer_fill_rect(renderer_target_buffer buffer, renderer_rect rect, uint32_t color) +{ + for (int y = rect.y; y < rect.y + rect.h; y++) + { + for(int x = rect.x; x < rect.x + rect.w; x++) + { + PutPixelXY(buffer, x, y, color); + } + } +} \\ No newline at end of file new file src/renderer.h @@ -0,0 +1,44 @@ +// renderer.h + +#ifndef RENDERER_INCLUDED +#define RENDERER_INCLUDED + +typedef struct renderer_target_buffer { + int32_t width; + int32_t height; + int32_t bytes_per_pixel; + uint8_t* pixels; +} renderer_target_buffer; + +typedef struct renderer_rect { + int32_t x; + int32_t y; + int32_t w; + int32_t h; +} renderer_rect; + +// Pack 3 color bytes into one uint32 +#define PackColorRGB(r, g, b) (r & 0xff) << 16 | (g & 0xff) << 8 | (b & 0xff) + +// Pack 4 color bytes into one uint32 +#define PackColorRGBA(r, g, b, a) (a & 0xff) << 24 | PackColorRGB(r, g, b) + +// Index pixel at x, y coordinates within renderer_target_buffer target +#define IndexPixel(x, y, target) (x + y * target.width) * target.bytes_per_pixel + +// Put pixel at offset into target +#define PutPixelByteOffset(target, offset, color) *(uint32_t *)(target.pixels + offset) = color + +// Put pixel at x,y into target +#define PutPixelXY(target, x, y, color) PutPixelByteOffset(target, IndexPixel(x, y, target), color) + +renderer_target_buffer +renderer_create_target_buffer(int32_t width, int32_t height, int32_t bytes_per_pixel, uint8_t* pixels); + +void +renderer_fill(renderer_target_buffer buffer, uint32_t color); + +void +renderer_fill_rect(renderer_target_buffer buffer, renderer_rect rect, uint32_t color); + +#endif // RENDERER_INCLUDED \\ No newline at end of file","title":"4. Manipulating Pixels"},{"location":"4_manipulating_pixels/#manipulating-pixels","text":"In the previous chapter we created a window and filled it with blue color. This works but it's cumbersome to index the correct location in the buffer as well as defining the color as a 32-bit integer. In this chapter we will look at creating another source file which will make all of that a lot easier. Paving the way to finally make some triangles appear.","title":"Manipulating Pixels"},{"location":"4_manipulating_pixels/#creating-the-renderer","text":"To keep the src/main.c file clean all the code related to rendering pixels will be inside src/renderer.c file. Let's create that file and associated header file. touch src/renderer.h touch src/renderer.c Initially the renderer will contain some macros to help define colors more easily, as well as indexing and writing pixels to the pixels byte array. To demonstrate this functionality we'll also add a function for filling the window with a color and filling a rectangle (subset of the window) with a color.","title":"Creating the Renderer"},{"location":"4_manipulating_pixels/#rendererh","text":"Start by filling in the header guard defines this is common practice for all header files to prevent them from being included every time: // renderer.h #ifndef RENDERER_INCLUDED #define RENDERER_INCLUDED // TODO: Declarations goes here #endif // RENDERER_INCLUDED Now replace the TODO: Declarations goes here comment with the following struct declaration. This struct will be used to pass information about the pixel buffer we're rendering into to the rendering. This helps keep the number of arguments we need to pass into macros and functions to a minimum. We'll also add a helper function for creating instances of this struct: typedef struct renderer_target_buffer { int32_t width; int32_t height; int32_t bytes_per_pixel; uint8_t* pixels; } renderer_target_buffer; renderer_target_buffer renderer_create_target_buffer(int32_t width, int32_t height, int32_t bytes_per_pixel, uint8_t* pixels); Declare the renderer_rect struct below the renderer_target_buffer struct declaration: typedef struct renderer_rect { int32_t x; int32_t y; int32_t w; int32_t h; } renderer_rect; Add the following macros below the renderer_rect struct. These macros help pack 3 or four channel color values into a single 32 bit integer, as well as indexing the pixel buffer by offset or x,y coordinates: // Pack 3 color bytes into one uint32 #define PackColorRGB(r, g, b) (r & 0xff) << 16 | (g & 0xff) << 8 | (b & 0xff) // Pack 4 color bytes into one uint32 #define PackColorRGBA(r, g, b, a) (a & 0xff) << 24 | PackColorRGB(r, g, b) // Index pixel at x, y coordinates within renderer_target_buffer target #define IndexPixel(x, y, target) (x + y * target.width) * target.bytes_per_pixel // Put pixel at offset into target #define PutPixelByteOffset(target, offset, color) *(uint32_t *)(target.pixels + offset) = color // Put pixel at x,y into target #define PutPixelXY(target, x, y, color) PutPixelByteOffset(target, IndexPixel(x, y, target), color) Below the macro definitions we can add the function declarations. We'll add three functions for now; one to help create the renderer_target_buffer structure and the two others to fill entire window or a part of the window with desired color: renderer_target_buffer renderer_create_target_buffer(int32_t width, int32_t height, int32_t bytes_per_pixel, uint8_t* pixels); void renderer_fill(renderer_target_buffer buffer, uint32_t color); void renderer_fill_rect(renderer_target_buffer buffer, renderer_rect rect, uint32_t color);","title":"renderer.h"},{"location":"4_manipulating_pixels/#rendererc","text":"The implementation of src/renderer.c will be fairily straight forward because of the macros and structure we've defined in the header. Put the following content inside the src/renderer.c file: // renderer.c #include <stdint.h> #include \"renderer.h\" renderer_target_buffer renderer_create_target_buffer(int32_t width, int32_t height, int32_t bytes_per_pixel, uint8_t *pixels) { renderer_target_buffer target = { width, height, bytes_per_pixel, pixels }; return target; } void renderer_fill(renderer_target_buffer buffer, uint32_t color) { uint32_t fill_until = buffer.width * buffer.height * buffer.bytes_per_pixel; uint32_t per_pixel_add = buffer.bytes_per_pixel; for (int offset = 0; offset < fill_until; offset += per_pixel_add) { PutPixelByteOffset(buffer, offset, color); } } void renderer_fill_rect(renderer_target_buffer buffer, renderer_rect rect, uint32_t color) { for (int y = rect.y; y < rect.y + rect.h; y++) { for(int x = rect.x; x < rect.x + rect.w; x++) { PutPixelXY(buffer, x, y, color); } } } Beware, there's no clipping implemented yet so passing in rectangles which goes outside the available pixel buffer space will cause segmentation faults or other memory related errors.","title":"renderer.c"},{"location":"4_manipulating_pixels/#testing","text":"We'll make some changes to src/main.c to test the new src/renderer.c implementation. Filling the window with a color like before as well as putting some colored squares in each corner of the window. Update src/main.c with the following, put this code between the game_window_surface_lock_pixels(game_window); and game_window_surface_unlock_and_update_pixels(game_window); lines: int32_t bytes_per_pixel = 4; renderer_target_buffer pixel_buffer = renderer_create_target_buffer(game_window->pixel_buffer_width, game_window->pixel_buffer_height, bytes_per_pixel, game_window->pixels); renderer_fill(pixel_buffer, PackColorRGB(0, 0, 255)); if (game_window->pixel_buffer_width != 0) { renderer_rect top_left = { 0, 0, 32, 32 }; renderer_rect top_right = { pixel_buffer.width - 32, 0, 32, 32 }; renderer_rect bottom_left = { 0, pixel_buffer.height - 32, 32, 32 }; renderer_rect bottom_right = { pixel_buffer.width - 32, pixel_buffer.height - 32, 32, 32 }; renderer_fill_rect(pixel_buffer, top_left, PackColorRGB(255, 0, 0)); renderer_fill_rect(pixel_buffer, top_right, PackColorRGB(0, 255, 0)); renderer_fill_rect(pixel_buffer, bottom_left, PackColorRGB(0, 255, 255)); renderer_fill_rect(pixel_buffer, bottom_right, PackColorRGB(255, 255, 0)); } Don't forget to include the src/renderer.h file at the top of src/main.c as well: #include \"renderer.h\" Now all that's left to do is updating the CMakeLists.txt to include src/renderer.c when building the application. add_executable(back_to_basics src/main.c src/game_window.c src/renderer.c) Now try to build the application and if everything was alright observe the results, it should look like this:","title":"Testing"},{"location":"4_manipulating_pixels/#full-diff-for-this-chapter","text":"modified CMakeLists.txt @@ -7,5 +7,5 @@ set(CMAKE_C_STANDARD 11) find_package(SDL2 REQUIRED) include_directories(back_to_basics ${SDL2_INCLUDE_DIRS}) -add_executable(back_to_basics src/main.c src/game_window.c) +add_executable(back_to_basics src/main.c src/game_window.c src/renderer.c) target_link_libraries(back_to_basics ${SDL2_LIBRARIES}) modified src/main.c @@ -3,6 +3,7 @@ #include <SDL2/SDL.h> #include \"game_window.h\" +#include \"renderer.h\" int main(int argc, char* argv[]) { @@ -21,14 +22,39 @@ int main(int argc, char* argv[]) game_window_surface_lock_pixels(game_window); - uint32_t *pixels_32bpp = (uint32_t *)game_window->pixels; - for (int y = 0; y < game_window->pixel_buffer_height; y++) + int32_t bytes_per_pixel = 4; + renderer_target_buffer pixel_buffer = + renderer_create_target_buffer(game_window->pixel_buffer_width, game_window->pixel_buffer_height, bytes_per_pixel, game_window->pixels); + + renderer_fill(pixel_buffer, PackColorRGB(0, 0, 255)); + + if (game_window->pixel_buffer_width != 0) { - uint32_t row = y * game_window->pixel_buffer_width; - for (int x = 0; x < game_window->pixel_buffer_width; x++) - { - pixels_32bpp[x + row] = 0xff0000ff; - } + renderer_rect top_left = { + 0, 0, 32, 32 + }; + + renderer_rect top_right = { + pixel_buffer.width - 32, + 0, 32, 32 + }; + + renderer_rect bottom_left = { + 0, + pixel_buffer.height - 32, + 32, 32 + }; + + renderer_rect bottom_right = { + pixel_buffer.width - 32, + pixel_buffer.height - 32, + 32, 32 + }; + + renderer_fill_rect(pixel_buffer, top_left, PackColorRGB(255, 0, 0)); + renderer_fill_rect(pixel_buffer, top_right, PackColorRGB(0, 255, 0)); + renderer_fill_rect(pixel_buffer, bottom_left, PackColorRGB(0, 255, 255)); + renderer_fill_rect(pixel_buffer, bottom_right, PackColorRGB(255, 255, 0)); } game_window_surface_unlock_and_update_pixels(game_window); new file src/renderer.c @@ -0,0 +1,37 @@ +// renderer.c + +#include <stdint.h> +#include \"renderer.h\" + +renderer_target_buffer +renderer_create_target_buffer(int32_t width, int32_t height, int32_t bytes_per_pixel, uint8_t *pixels) +{ + renderer_target_buffer target = { + width, height, bytes_per_pixel, pixels + }; + + return target; +} + +void +renderer_fill(renderer_target_buffer buffer, uint32_t color) +{ + uint32_t fill_until = buffer.width * buffer.height * buffer.bytes_per_pixel; + uint32_t per_pixel_add = buffer.bytes_per_pixel; + for (int offset = 0; offset < fill_until; offset += per_pixel_add) + { + PutPixelByteOffset(buffer, offset, color); + } +} + +void +renderer_fill_rect(renderer_target_buffer buffer, renderer_rect rect, uint32_t color) +{ + for (int y = rect.y; y < rect.y + rect.h; y++) + { + for(int x = rect.x; x < rect.x + rect.w; x++) + { + PutPixelXY(buffer, x, y, color); + } + } +} \\ No newline at end of file new file src/renderer.h @@ -0,0 +1,44 @@ +// renderer.h + +#ifndef RENDERER_INCLUDED +#define RENDERER_INCLUDED + +typedef struct renderer_target_buffer { + int32_t width; + int32_t height; + int32_t bytes_per_pixel; + uint8_t* pixels; +} renderer_target_buffer; + +typedef struct renderer_rect { + int32_t x; + int32_t y; + int32_t w; + int32_t h; +} renderer_rect; + +// Pack 3 color bytes into one uint32 +#define PackColorRGB(r, g, b) (r & 0xff) << 16 | (g & 0xff) << 8 | (b & 0xff) + +// Pack 4 color bytes into one uint32 +#define PackColorRGBA(r, g, b, a) (a & 0xff) << 24 | PackColorRGB(r, g, b) + +// Index pixel at x, y coordinates within renderer_target_buffer target +#define IndexPixel(x, y, target) (x + y * target.width) * target.bytes_per_pixel + +// Put pixel at offset into target +#define PutPixelByteOffset(target, offset, color) *(uint32_t *)(target.pixels + offset) = color + +// Put pixel at x,y into target +#define PutPixelXY(target, x, y, color) PutPixelByteOffset(target, IndexPixel(x, y, target), color) + +renderer_target_buffer +renderer_create_target_buffer(int32_t width, int32_t height, int32_t bytes_per_pixel, uint8_t* pixels); + +void +renderer_fill(renderer_target_buffer buffer, uint32_t color); + +void +renderer_fill_rect(renderer_target_buffer buffer, renderer_rect rect, uint32_t color); + +#endif // RENDERER_INCLUDED \\ No newline at end of file","title":"Full diff for this chapter"}]}